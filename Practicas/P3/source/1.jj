
options {
    STATIC=false;
}

PARSER_BEGIN(Compilador)


public class Compilador {
    public static void main(String args[]) throws java.io.FileNotFoundException {
        //final Stack<String> stack = new Stack<String>();

        try {
            final Compilador compilador = initCompilador(args);
            compilador.parse();        
        } catch (java.io.FileNotFoundException ex) {
            System.out.println("File not found (" + args[0] + "), first argument must be a valid path.");
        } catch (ParseException ex) {
            System.out.println(ex);
            System.out.println("Parser caught an unexpected exception, exiting...");
        }
    }

    static Compilador initCompilador(String args[]) throws java.io.FileNotFoundException {
        if (args.length < 1) {
            return new Compilador(System.in);
        }
        return new Compilador(new java.io.FileInputStream(args[0]));
    }


    public static int labelCount = 0;
    public static int getLabel() {
        return Compilador.labelCount-1;
    }
    public static int getNewLabel() {
        return Compilador.labelCount++;
    }

    

}
PARSER_END(Compilador)

TOKEN_MGR_DECLS : {}

/* ALL */
TOKEN : {
    <NUM: (["0"-"9"])+ >
|   <#CHARAC: ["A"-"Z", "a"-"z"]>
|   <COMPUTE:"COMPUTE">
|   <EQUAL:"=">
|   <MOVE:"MOVE">
|   <TO:"TO">
|   <IF:"IF">
|   <THEN:"THEN">
|   <EVALUATE:"EVALUATE">
|   <END_EVALUATE:"END-EVALUATE">
|   <PERFORM:"PERFORM">
|   <UNTIL:"UNTIL">
|   <END_PERFORM:"END-PERFORM">
|   <DISPLAY:"DISPLAY">
|   <ELSE:"ELSE">
|   <END_IF:"END-IF">
|   <WHEN:"WHEN">
|   <ADDITION:"+">
|   <SUBSTRACTION:"-">
|   <MULTIPLICATION: "*">
|   <DIVISION: "/">
|   <PARENTHESIS_START: "(">
|   <PARENTHESIS_END: ")">
|   <ID: (<CHARAC>)(<CHARAC>|<NUM>)* >

}
SKIP : {
     <~[]>
|    <"**"(~["\n", "\r"])*>
}


void parse() : {} {
    sentences()
}

void sentences() : {} {
    //Recursividad de izquierdas
     sent() (sentences())?
}

void sent() : {int label;} {
    assig()| proc()
}


void assig() : {
    Token id, num;
    int label;
} {
    (<COMPUTE> id=<ID>{ label = getNewLabel(); System.out.println("\tsiciertovea LBL"+label); System.out.println("\tvalori "+id.image);} <EQUAL> arithexp() 
    //Fix below line
|   <MOVE> /*fac()*/num=<NUM> <TO> id=<ID>{
        System.out.println("\tvalori "+id.image);
        System.out.println("\tmete "+num.image);}) {
        System.out.println("\tasigna");
        }//fac()
}

void proc() : { int label, prevLabel, auxLabel; } {
    {prevLabel=getLabel();}<IF>   arithexp(){  label = getNewLabel(); System.out.println("\tsifalsoveo LBL"+label);}  sentences() auxLabel=elseopt(label){System.out.println("LBL"+auxLabel);}//LBL1
|   <EVALUATE> <ID> (whenclause())+ <END_EVALUATE>
|   <PERFORM> { label = getNewLabel(); System.out.println("LBL"+label);} <UNTIL> arithexp() sentences() {System.out.println("\tvea LBL"+label);System.out.println("LBL"+(label+1));}<END_PERFORM>//Vea LBL0
|   <DISPLAY> arithexp() { System.out.println("\tprint"); }
    
}


int elseopt(int prevLabel) : {int label;} {
    <ELSE> { label = getNewLabel(); System.out.println("\tvea LBL"+label);System.out.println("LBL"+prevLabel);} sentences() <END_IF>{return label;}
|   <END_IF>{label = getNewLabel(); return label;}
}
void whenclause() : {} {
    <WHEN> arithexp() sentences()
}
void arithexp() : {} {
    //Recursividad de izquierdas
    multexp() arithexpP()
}
/*void multexp() : {} {
    ( (<MULTIPLICATION> | <DIVISION>) multexp() fac() | fac() )
}*/



void arithexpP(): {
    String op;
} {
  ( ( <ADDITION> multexp() arithexpP(){ op = "sum";}
|   <SUBSTRACTION> multexp() arithexpP() {op="sub";}) {System.out.println('\t' + op);})?


}

void multexp(): {} {
    //Recursividad de izquierdas
    fac() multexpP()
}


void multexpP(): {
    String op;
} {
   (( <MULTIPLICATION> fac() multexpP() { op = "mul";}
|   <DIVISION> fac() multexpP() {op="div";}) {System.out.println('\t' + op);})?

}
void fac() : {
    Token token;
} {
    token = <NUM> { System.out.println("\tmete " + token.image); }
|   token = <ID> { System.out.println("\tvalord " + token.image);  }
|   <PARENTHESIS_START>  arithexp() <PARENTHESIS_END> 
}


